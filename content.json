{"meta":{"title":"1k2m5's blog","subtitle":null,"description":null,"author":"1k2m5","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-01-02T01:06:25.000Z","updated":"2018-01-02T01:07:27.344Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ajax","slug":"ajax","date":"2018-01-02T15:05:00.000Z","updated":"2018-01-02T15:05:56.514Z","comments":true,"path":"2018/01/02/ajax/","link":"","permalink":"http://yoursite.com/2018/01/02/ajax/","excerpt":"","text":"一、AJAX简介$.ajax() AJAX(Asynchronous Javascript And XML)异步Javascript和XML 用Javascript语言与服务器进行异步交互，传送的数据为XML(现在传JSON，不用XML) 两大特点 局部刷新，交互性更强，用户体验好 异步传送，效率高，但对server端压力大 二、工作原理javascript 异步数据获取技术XmlHTTPRequest xml Dom XHTML和CSS 核心：XmlHTTPRequest onreadystatechange 123456789request.onreadystatechange = function()&#123; if(request.readyState == 4)&#123; //从服务器获取数据的代码，并做响应处理 alert(request.responseText); &#125;&#125;request.send(null); readyState属性 5个值： 0请求未初始化 1请求已提出 2请求已发送 3服务器正在处理中，未响应完成 4服务器处理完成 responseText open() GET/POST URL 异步处理标志 send() request.open(“GRT”,”test.txt”,true) 三、基于JS的ajax的实现 创建核心对象 123456var xmlhttp=new XmlHTTPRequest() #firfox,opera,safarixmlhttp = new ActiveXObject(&apos;Msxml2.XMLHTTP&apos;) #IE6+xmlhttp = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;) 使用核心对象打开服务器的连接 xmlhttp.open(&quot;&quot;)#填请求路径 发送请求 xmlhttp.send(&quot;name=a&quot;)#请求体的内容 if get请求：send(null) 注册监听，监听服务器响应 xmlhttp(if == 4:{var context = xmlhttp.responetext})","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"","slug":"Django_models","date":"2017-12-26T02:44:24.291Z","updated":"2018-01-02T14:55:40.977Z","comments":true,"path":"2017/12/26/Django_models/","link":"","permalink":"http://yoursite.com/2017/12/26/Django_models/","excerpt":"","text":"title: Django_modelsdate: 2017-12-26 10:44:24 tags: Django框架一、ORM(对象关系映射)ORM使得数据库交互变得简单，不用考虑SQL语句。但是性能上面可能会差一点。 创建表 创建单表（与其他表无关） 创建关联表（foreignKey） 一对一(OneToOne) 一对多(ForeignKey)自动添加_id 多对多(ManyToMany)操作表(对行对象操作)： 增：create 1、models.Book.objects.create(title=&quot;Python&quot;,price=&quot;12&quot;) 2、dic={&quot;title&quot;:&quot;python&quot;,&quot;price&quot;:12} models.Book.objects.create(**dic) 如果有外键： 一对多：models.Book.objects.create(title=&quot;Python&quot;,price=&quot;12&quot;) 多对多：add() remove() 自动创建ManyToMany #正向查询 book = models.Book.objects.filter(id=2)[0] authors=models.Author.objects.filter(id__gt=2)#id大于2 book.author.add(*authors) book.author.remove(*authors) #反向查询 author = models.Author.objects.filter(id=2) books = models.Book.objects.filter(id__gt=2) author.book_set.add(*books)#book_set是一个QuerySet集合 author.book_set.remove(*books) 自己创建第三张表OneToOne 通过两个Foreignkey，unique=True class Book2Author(models.Model): author = models.ForeignKey(&quot;Author&quot;) book = models.ForeignKey(&quot;Book&quot;) class Meta: unique_together = [&quot;author&quot;,&quot;book&quot;] save 1、obj.Book(title=&quot;python&quot;,price=12) obj.save() 2、obj=Book() obj.title=&quot;GO&quot; obj.price=12 obj.save() 删 改 查 str方法 class Person(): def __init__(self,name): self.name = name obj = Person(&quot;alex&quot;) print(obj) 产生结果：&lt;__main__.Person object at 0x0094A430&gt; 创建表的一些操作：models.CharFieldmodels.BooleanFieldmodels.DateField 命令行创建表python manage.py makemigrationspython manage.py migrate 表的操作增create,savefrom app01.models import * #create方式一: Author.objects.create(name=&apos;Alvin&apos;) #create方式二: Author.objects.create(**{&quot;name&quot;:&quot;alex&quot;})#(建议用这种) #save方式一: author=Author(name=&quot;alvin&quot;) author.save() #save方式二: author=Author() author.name=&quot;alvin&quot; author.save() 创建一对多 #一对多(ForeignKey): #方式一: 由于绑定一对多的字段,比如publish,存到数据库中的字段名叫publish_id,所以我们可以直接给这个 # 字段设定对应值: Book.objects.create(title=&apos;php&apos;, publisher_id=2, #这里的2是指为该book对象绑定了Publisher表中id=2的行对象 publication_date=&apos;2017-7-7&apos;, price=99) #方式二: # &lt;1&gt; 先获取要绑定的Publisher对象: pub_obj=Publisher(name=&apos;河大出版社&apos;,address=&apos;保定&apos;,city=&apos;保定&apos;, state_province=&apos;河北&apos;,country=&apos;China&apos;,website=&apos;http://www.hbu.com&apos;) OR pub_obj=Publisher.objects.get(id=1) # &lt;2&gt;将 publisher_id=2 改为 publisher=pub_obj #多对多(ManyToManyField()): author1=Author.objects.get(id=1) author2=Author.objects.filter(name=&apos;alvin&apos;)[0] book=Book.objects.get(id=1) book.authors.add(author1,author2) #等同于: book.authors.add(*[author1,author2]) book.authors.remove(*[author1,author2]) #------------------- book=models.Book.objects.filter(id__gt=1) authors=models.Author.objects.filter(id=1)[0] authors.book_set.add(*book) authors.book_set.remove(*book) #------------------- book.authors.add(1) book.authors.remove(1) authors.book_set.add(1) authors.book_set.remove(1) #注意: 如果第三张表是通过models.ManyToManyField()自动创建的,那么绑定关系只有上面一种方式 # 如果第三张表是自己创建的: class Book2Author(models.Model): author=models.ForeignKey(&quot;Author&quot;) Book= models.ForeignKey(&quot;Book&quot;) # 那么就还有一种方式: author_obj=models.Author.objects.filter(id=2)[0] book_obj =models.Book.objects.filter(id=3)[0] s=models.Book2Author.objects.create(author_id=1,Book_id=2) s.save() s=models.Book2Author(author=author_obj,Book_id=1) s.save() 删deleteBook.objects.filter(id=1).delete()级联删除 改update，savesave拿到对象，对整个集合更改一次，即使数据没变。update集合对象才能调用，拿到集合,update效率高 author=Author.objects.get(id=5) author.name=&apos;I&apos; author.save() Publisher.objects.filter(id=2).update(name=&apos;I&apos;)#不能用get(id=2) * 第二种方式修改不能用get的原因是：update是QuerySet对象的方法，get返回的是一个model对象，它没有update方法，而filter返回的是一个QuerySet对象(filter里面的条件可能有多个条件符合，比如name＝’alvin’,可能有两个name＝’alvin’的行数据)。 save()方法会更新一行里的所有列。效率低* 查filter,value# 查询相关API： # &lt;1&gt;filter(**kwargs): 它包含了与所给筛选条件相匹配的对象，拿到集合 # &lt;2&gt;all(): 查询所有结果，拿到集合 # &lt;3&gt;get(**kwargs): 返回与所给筛选条件相匹配的对象，返回结果有且只有一个，如果符合筛选条件的对象超过一个或者没有都会抛出错误。拿到一个对象 #-----------下面的方法都是对查询的结果再进行处理:比如 objects.filter.values()-------- # &lt;4&gt;values(*field): 返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列 model的实例化对象，而是一个可迭代的字典序列 # &lt;5&gt;exclude(**kwargs): 它包含了与所给筛选条件不匹配的对象 # &lt;6&gt;order_by(*field): 对查询结果排序，order_by(-*field) # &lt;7&gt;reverse(): 对查询结果反向排序 # &lt;8&gt;distinct(): 从返回结果中剔除重复纪录 # &lt;9&gt;values_list(*field): 它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列 # &lt;10&gt;count(): 返回数据库中匹配查询(QuerySet)的对象数量。 # &lt;11&gt;first(): 返回第一条记录 # &lt;12&gt;last(): 返回最后一条记录 # &lt;13&gt;exists(): 如果QuerySet包含数据，就返回True，否则返回False QuerySet惰性机制可迭代，可切片惰性机制：Publisher.objects.all()或者.filter()等都只是返回了一个QuerySet（查询结果集对象），它并不会马上执行sql，而是当调用QuerySet的时候才执行。 打印日志（写入到settings中）LOGGING = { &apos;version&apos;: 1, &apos;disable_existing_loggers&apos;: False, &apos;handlers&apos;: { &apos;console&apos;:{ &apos;level&apos;:&apos;DEBUG&apos;, &apos;class&apos;:&apos;logging.StreamHandler&apos;, }, }, &apos;loggers&apos;: { &apos;django.db.backends&apos;: { &apos;handlers&apos;: [&apos;console&apos;], &apos;propagate&apos;: True, &apos;level&apos;:&apos;DEBUG&apos;, }, } } 聚合查询与分组查询aggregateBook.objects.filter(author_name=”alex”).aggregate(SUM(“price”)) annotateBook.objects.values(“author_name”).annotate(SUM(“price”)) F查询和Q查询F查询 对对象中某个列的值进行操作from django.db.models import Fmodels.Book.objects.all().update(price=F(&quot;price&quot;+20)) Q查询 灵活查询，封装关键字查询from django.db.models import Q1.进行组合| or&amp; and~ not obj=models.Book.objects.filter（Q(id=3) | Q(title=&quot;php&quot;))[0] 2.你 obj=models.Book.objects.filter（Q(id=3) | Q(title=&quot;php&quot;),color=&quot;red&quot;)[0] 二、连接MYSQL","categories":[],"tags":[]},{"title":"Django_view&url","slug":"Django_view&url","date":"2017-12-26T00:24:52.000Z","updated":"2018-01-02T07:19:58.074Z","comments":true,"path":"2017/12/26/Django_view&url/","link":"","permalink":"http://yoursite.com/2017/12/26/Django_view&url/","excerpt":"","text":"本文中代码不可直接借鉴，由于模板语言与md存在命名规则冲突，文中代码会出现缺少{\\%的问题 一、 配置、启动1.django-admin startproject mysitesettings 配置设置urls 路由分配wsgi web服务器 manage.py —– Django项目里面的工具，通过它可以调用django shell和数据库等。settings.py —- 包含了项目的默认设置，包括数据库信息，调试标志以及其他一些工作的变量。urls.py —– 负责把URL模式映射到应用程序。views.py—– 视图函数,处理网页数据 2.在mysite 目录下创建blog应用python manage.py startapp blogblog文件中models.py ormviews.py httpresponse实例化 requesttest.py 检测用admin.py 强大之处 3.启动Django项目python manage.py runserver 8080 创建APPpython manage.py startapp app01 二、 url路由系统1.url与视图函数之间的映射表url(正则表达式，视图函数，参数，别名) 2.正则表达式以开头，以$结尾视图函数拿到的都是字符串*url(r’^articles/([0-9]{4})/([0-9]{2})/([0-9]+)/$’, views.article_detail), 代表重一到无穷次 3.有命名分组url(r’^index/(?P[0-9]{4})’,views.index,{“name”:’alex’})后面name 覆盖前面的值 4.对URL起别名action={\\% url “alex” %} 5.模板语言{\\% for i in user_list%} {\\% endfor %} 三、标签form&gt;input*3按TAB&#39;django.middleware.csrf.CsrfViewMiddleware&#39;安全验证将csrf_token加入HTML中 用于生成csrf_token的标签，用于防治跨站攻击验证。 其实，这里是会生成一个input标签，和其他表单标签一起提交给后台的。 if for with 用更简单的变量名替代复杂的变量名 url 引用路由配置 load 加载标签库 verbatim 禁止renderforloop.counter 计数器必须在INSTALLED_APPS中添加APP名称 四、Template和Context 格式化输出:&quot;%s&quot; 变量 前后端分离 模板语言：html+逻辑控制语句，作用：纽带 后端： 12`&#123;&quot;abc&quot;:times&#125;``&#123;&quot;abc&quot;:&quot;hello&quot;&#125;` 前端： render(请求文件,模板,context) return render(request,”cur_time.html”,{“abc”:times}) 命令行如何显示python manage.py shell进入项目的Django环境from django.template import Context,Templatet=Template(&quot;hello&quot;)c=Context({&quot;name&quot;:&quot;alex&quot;})t渲染c t.render(c)一个模板可以渲染多个context对象 12345678910```#lowfor name in (&apos;John&apos;,&apos;Julie&apos;,&apos;Pat&apos;): t = Tempalte(&apos;Hello,&#123;&#123;name&#125;&#125;&apos;) print t.render(Context(&#123;&apos;name&apos;:name&#125;))#Goodt = Template(&apos;Hello,&#123;&#123;name&#125;&#125;&apos;)for name in (&apos;John&apos;,&apos;Julie&apos;,&apos;Pat&apos;): print t.render(Context(&#123;&apos;name&apos;:name&#125;)) Django模板解析非常快捷，大部分的解析工作都市在后台通过对简短正则表达式一次性调用来完成。这和基于XML的模板引擎形成鲜明对比，那些引擎承担了xml解析器的开销，且往往比Django模板渲染引擎要满上几个数量级。 12345678910111213141516171819202122232425262728293031323334from django.shortcuts import render,HttpResponsefrom django.template.loader import get_template #记得导入# Create your views here.import datetimefrom django.template import Template,Context# def current_time(req): #原始的视图函数 # now=datetime.datetime.now() # html=&quot;&lt;html&gt;&lt;body&gt;现在时刻：&lt;h1&gt;%s.&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot; %now # return HttpResponse(html)# def current_time(req): #django模板修改的视图函数# now=datetime.datetime.now()# t=Template(&apos;&lt;html&gt;&lt;body&gt;现在时刻是:&lt;h1 style=&quot;color:red&quot;&gt;&#123;&#123;current_date&#125;&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;) #t=get_template(&apos;current_datetime.html&apos;)# c=Context(&#123;&apos;current_date&apos;:now&#125;)# html=t.render(c)# return HttpResponse(html)#另一种写法(推荐)def current_time(req): now=datetime.datetime.now() return render(req, &apos;current_datetime.html&apos;, &#123;&apos;current_date&apos;:now&#125;) 五、 过滤器filter万能的句点号sys.path 记录搜索变量的路径，项目加载的时候回添加到项目根目录位置模板语言中没有中括号，用句点号 if循环计时，从1开始计counter0从0开始计 filter,sample_tagfilter参数不能超过两个filter格式第一个参数|filter名：第二个参数sample_tag不能用于ifsample_tag格式sample_tag函数名 第一个参数 第二个参数 第三个参数 常用过滤器 add ： 给变量加上相应的值 addslashes : 给变量中的引号前加上斜线 capfirst : 首字母大写 cut ： 从字符串中移除指定的字符 date ： 格式化日期字符串 default ： 如果值是False,就替换成设置的默认值，否则就是用本来的值 default_if_none: 如果值是None，就替换成设置的默认值，否则就使用本来的值 六、模板 继承在HTML中 可替换的部分 用 block endblock包起来在填充 HTML中 extends 继承父HTML文件，而且可以邮以下形式1234block block endblockendblock 创建 123&lt;1&gt; 创建 base.html 模板，在其中定义站点的主要外观感受。 这些都是不常修改甚至从不修改的部分。&lt;2&gt; 为网站的每个区域创建 base_SECTION.html 模板(例如, base_photos.html 和 base_forum.html )。这些模板对base.html 进行拓展，并包含区域特定的风格与设计。&lt;3&gt; 为每种类型的页面创建独立的模板，例如论坛页面或者图片库。 这些模板拓展相应的区域模板。 注意1234 &lt;1&gt;如果在模板中使用 extends必须保证其为模板中的第一个模板标记。 否则，模板继承将不起作用 &lt;2&gt;一般来说，基础模板中的block标签越多越好。 &lt;3&gt;如果发觉自己在多个模板之间拷贝代码，你应该考虑将该代码段放置到父模板的某个 block中。如果要访问父模板中的块的内容，使用 &#123;&#123; block.super &#125;&#125;这个标签&lt;4&gt;不允许在同一个模板中定义多个同名的 block。存在这样的限制是因为block 标签的工作方式是双向的。block 标签不仅挖了一个要填的坑，也定义了在父模板中这个坑所填充的内容。如果模板中出现了两个相同名称的block标签，父模板将无从得知要使用哪个块的内容。 小结12345678910- render(req,template对象，context对象)- 句点号（调用列表，属性）- 两个大括号加变量- &#123;var_name|filter&#125;|管道符后面用Filter过滤器（addslashes 给变量中的引号前加深斜线）- |管道符后面加safe，变量是含HTML标签的特殊字符串让HTML渲染。- sample_tag（可以传多个参数，但不能用于if for语句）和filter（最多两个参数，第一个参数是管道符前的数）- 在settings中 `Installapps（app）`- 文件夹的名字固定：templatetags tags- .html文件最上面&#123;\\%load tags%\\&#125;- 继承 extends 为了避免重复，调用模板","categories":[],"tags":[{"name":"Django框架","slug":"Django框架","permalink":"http://yoursite.com/tags/Django框架/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-21T13:03:18.664Z","updated":"2017-12-21T13:03:18.664Z","comments":true,"path":"2017/12/21/hello-world/","link":"","permalink":"http://yoursite.com/2017/12/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}